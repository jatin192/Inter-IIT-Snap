<!doctype html>
<html>
</head>
<title>Hello, Snaps!</title>
<link rel="icon" type="image/svg" href="./images/icon.svg" />
</head>

<body>
  <h1>Hello, Snaps!</h1>
  <details>
    <summary>Instructions</summary>
    <ul>
      <li>First, click "Connect". Then, try out the other buttons!</li>
      <li>Please note that:</li>
      <ul>
        <li>
          The <code>snap.manifest.json</code> and <code>package.json</code> must be located in the server root
          directory..
        </li>
        <li>
          The Snap bundle must be hosted at the location specified by the <code>location</code> field of
          <code>snap.manifest.json</code>.
        </li>
      </ul>
    </ul>
  </details>
  <br />

  <button class="connect">Connect</button>
  <button class="sendHello">Send Hello</button>
  <button class="getAddresses">Get Addresses</button>


  <input type="file" id="fileUpload" />
  <input type="button" id="upload" value="Upload" onclick="Upload()" />
  <hr />
  <div id="dvCSV">
  </div>

  <button onclick="makeJson()">PayNow</button>

  <form id="storeAddress">
    <fieldset>
      <legend>Save an address to your address book</legend>
      <label for="nameToStore">Name</label>
      <input type="text" id="nameToStore" name="nameToStore"><br>
      <label for="addressToStore">Address</label>
      <input type="text" id="addressToStore" name="addressToStore"><br>
      <input type="submit" id="storeAddress" value="Save">
    </fieldset>
  </form>

  <div>
    <p>My address book</p>
    <pre id="addressBook"></pre>
  </div>


  <script>

    function Upload() {
      var fileUpload = document.getElementById("fileUpload");
      var regex = /^([a-zA-Z0-9\s_\\.\-:])+(.csv|.txt)$/;
      if (regex.test(fileUpload.value.toLowerCase())) {
        if (typeof (FileReader) != "undefined") {
          var reader = new FileReader();
          reader.onload = function (e) {
            var table = document.createElement("table");
            var rows = e.target.result.split("\n");
            for (var i = 0; i < rows.length; i++) {
              var cells = rows[i].split(",");
              if (cells.length > 1) {
                var row = table.insertRow(-1);
                for (var j = 0; j < cells.length; j++) {
                  var cell = row.insertCell(-1);
                  cell.innerHTML = cells[j];
                }
              }
            }
            var dvCSV = document.getElementById("dvCSV");
            dvCSV.innerHTML = "";
            dvCSV.appendChild(table);
          }
          reader.readAsText(fileUpload.files[0]);
        } else {
          alert("This browser does not support HTML5.");
        }
      } else {
        alert("Please upload a valid CSV file.");
      }
    }


    async function makeJson() {
      var table = document.querySelector("table");
      var header = [];
      var rows = [];

      for (var i = 0; i < table.rows[0].cells.length; i++) {
        header.push(table.rows[0].cells[i].innerHTML);
      }
      for (var i = 1; i < table.rows.length; i++) {
        var row = {
          Receiver: '',
          Value: '',
        };
        row.Receiver = table.rows[i].cells[0].innerHTML
        row.Value = table.rows[i].cells[1].innerHTML

        rows.push(row);
      }

      accounts = await ethereum.request({ method: 'eth_requestAccounts' });
      const transactionDetails = rows;
      arrayOfData = [];
      transactionDetails.map(data => {
        const detail = {
          to: data.Receiver, // Required except during contract publications.
          from: accounts[0], // must match user's active address.
          value: data.Value,// Only required to send ether to the recipient from the initiating external account.
          data:
            '0x7f7465737432000000000000000000000000000000000000000000000000000000600057', // Optional, but used for defining smart contract creation and interaction.
          chainId: '0x5', // Used to prevent transaction reuse across blockchains. Auto-filled by MetaMask.
        };
        if (detail.to != '' && detail.value != '') {
          detail.value = detail.value.slice(0, -1);

          arrayOfData.push(detail);
        }

        
      })

      makePayments(arrayOfData);
      
    }


    const snapId = `local:${window.location.href}`;

    const connectButton = document.querySelector('button.connect')
    const sendButton = document.querySelector('button.sendHello')
    const getButton = document.querySelector('button.getAddresses');

    connectButton.addEventListener('click', connect)
    sendButton.addEventListener('click', send)
    getButton.addEventListener('click', getAddresses);

    // here we get permissions to interact with and install the snap
    async function connect() {
      await ethereum.request({
        method: 'wallet_enable',
        params: [{
          wallet_snap: { [snapId]: {} },
        }]
      })
      getAddresses()
    }

    // here we call the snap's "hello" method
    async function send() {
      try {
        const response = await ethereum.request({
          method: 'wallet_invokeSnap',
          params: [snapId, {
            method: 'hello'
          }]
        })
      } catch (err) {
        console.error(err)
        alert('Problem happened: ' + err.message || err)
      }
    }

    async function getAddresses() {
      let response = [];
      try {
        response = await ethereum.request({
          method: 'wallet_invokeSnap',
          params: [snapId, {
            method: 'retrieveAddresses'
          }]
        })
      } catch (err) {
        console.error(err)
        alert('Problem happened: ' + err.message || err)
      }
      document.getElementById('addressBook').textContent = '' + response.map(function (item) {
        return `${item.name}: ${item.address}`;
      }).join("\n");
    }

    const storeAddressForm = document.getElementById('storeAddress')
    storeAddressForm.addEventListener('submit', storeAddress)

    async function storeAddress(e) {
      e.preventDefault() // to prevent default form behavior 

      const name = document.getElementById('nameToStore').value
      const address = document.getElementById('addressToStore').value

      try {
        const response = await ethereum.request({
          method: 'wallet_invokeSnap',
          params: [snapId, {
            method: 'storeAddress',
            params: {
              nameToStore: name,
              addressToStore: address
            }
          }]
        })
        getAddresses()
      } catch (err) {
        console.error(err)
        alert('Problem happened: ' + err.message || err)
      }
    }

    async function makePayments(transactionDetails) {
      for(let index = 0; index < transactionDetails.length; index++)
      {
        console.log("this is running")
        await ethereum.request({
          method: 'eth_sendTransaction',
          params: [transactionDetails[index]]
        })

        console.log(
          "This is statement one"
        )
        setTimeout(()=>{}, 60000);
        console.log(
        'this is statement two'
        )
      }
    }



  </script>